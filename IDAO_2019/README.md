Our third championship in Team ML (Оля Дорноступ, Александра Ли, Динар Шарафутдинов). 

<b>Results:</b> public 44/186, private 31/83 

+19% from baseline

https://idao.world/

https://github.com/yandexdataschool/IDAO-2019-muon-id 

<b>data:</b> https://yadi.sk/d/pdwdp4Lt5X4DMQ

<b>Description:</b>

Task outline
Objective:

The task is to build a classiﬁer that would distinguish muons from non-muons in the LHCb detector.
Background:

Beginning from the beginning. Normal matter, the one that planets, humans and stars are made of, make up only 5% of mass in the Universe. The rest are invisible dark matter and dark energy whose existence might be hinted through the gravitational eﬀects. One way of studying these mysteries is to recreate conditions just aster the Big Bang with particle accelerators. Using a very rough analogy, we collide automobiles at supersonic speed and try to learn how they work by looking at the photos of the collisions. One of such photo cameras is the LHCb detector.
The figure shows a typical collision event recorded by the LHCb detector, one of the four big experiments at the Large Hadron collider. Point to the left is where the protons collided, the lines are the the secondary particles tracks.

Your goal is to build an algorithm that distinguishes the muon tracks (green) from the tracks of the other particle types, using the information from the Muon subdetector. This is an extremely important problem, muon identiﬁcation is used, one way or another, in the majority of experiments at LHCb.
Muon subdetector (see the figure below) consists of ﬁve stations (sensitive planes perpendicular to the beam pipe). Only four of them are used in our competition (M2-M5). Green parallelepipeds in the 3D-figure above are the detector pads which registered a charged particle passing through them. The physical idea is that only muons have penetration ability high enough to allow them to pass though the lead shielding that separates the Muon subdetector from the rest of the detector. Of course, in the real world not all hits are generated by muons, that’s why we need machine learning.

You are given tracks of three types: muon, pion and proton. Pions might decay in ﬂight into genuine muons, so some of their tracks are very muon-like, you want to reject them as well.

The data is real (i. e. not simulated) and the particle types cannot be known with certainty. To account for that, we use a statistical method called sPlot (original paper, blog post). Each example is assigned a weight, when used with those weights, the distribution of the features matches the distribution over type-pure samples. Some of the weights are negative, this is expected.

Since the data for different particle types have been obtained from different decays, the distributions of the tracks kinematical observables are different. But in the end we need an algorithm that differentiates particle types in general, not only in the specific decays. In ML terms, this can be viewed as domain adaptation. To achieve that we reweighted the sample so that the distributions in momentum of signal and background match.

For convenience, the training dataset is split into two files. In the ﬁrst phase of the competition (we call it public) the models are scored using 20% of the test data (test_public). Two days prior to the competition’s end the rest 80% of test data will be released and phase two (private) will begin. Within the last two days the competitors should submit their predictions in the "Track 1: private" tab. The ﬁnal standings will be based on private leaderboard, which will be revealed at the end of the competition.

The data is present in two formats: csv and hdf. Both have been created with pandas (see the environment.yml for versions), hdf contains pickled numpy arrays, so it might not be readable outside Python.

Input format
Dataset fields description:
label, integer in {0,1} — you need to predict it. 0 is background (pions and protons), 1 is signal (muons).
particle_type, integer in {0,1,2} — type of the particle. 0 — pion, 1 — muon, 2 — proton. Available only for the training dataset.
weight, float — example weight, used in both training and evaluation. Product of sWeight and kinWeight.
sWeight, float — a component of the example weight that accounts for uncertainty in labeling.
kinWeight, float > 0 — a component of the example weight that equalizes kinematic observables between signal and background.
id, integer — this is an identiﬁcation field of the example.
Lextra_{X,Y}[N], float — coordinates of the track extrapolation intersection with N-th station.
Mextra_{X,Y,Z}2[N], float — multiple scattering uncertainty for squared {X, Y, Z} coordinate of the track extrapolation.
MatchedHit_{X,Y,Z}[N], float — coordinates of the hit in the N-th station that a physics-based tracking algorithm associated with the track. See the poster about the algorithm.
MatchedHit_TYPE[N], categorical in {1, 2} — whether the matched hit is crossed. 1 means uncrossed, 2 means crossed. See pages 6-8 here.
MatchedHit_T[N], integer in [1, 20] — timing of the matched hit.
MatchedHit_D{X,Y,Z}[N], float > 0 — uncertainty of the matched hit coordinates.
MatchedHit_DT[N], integer — delta time for the matched hit in the N-th station.
FOI_hits_N, integer — number of hits inside a physics-deﬁned cone around the track (aka Field Of Interest, FOI).
FOI_hits_{,D}{X,Y,Z,T}, array of float of size FOI_hits_N — same as MatchedHit{,D}{X,Y,Z,T}, per hit.
FOI_hits_S, integer in {0, 1, 2, 3} — stations of the FOI hits.
ncl[N], integer — number of clusters in the N-th station (high-level variable).
avg_cs[N], float ≥ 1 — average cluster size in the N-th station (high-level variable).
ndof, integer in {4, 6, 8} — number of degrees of freedom used in 
χ
2
 computation, a function of momentum.
NShared, integer ≥ 0 — number of closest hits shared with the neighbouring tracks. See pages 10-11 here.
P, float ≥ 3000 — momentum modulo, MeV/c.
PT, float ≥ 800 — component of the momentum transverse (i.e. perpendicular) to the beam line, MeV/c.
-9999 is used for missing values.

The data can be found in the shared Yandex.Disk folder. Note that Yandex.Disk has the convenient API.
